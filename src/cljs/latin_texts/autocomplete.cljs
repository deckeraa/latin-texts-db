(ns latin-texts.autocomplete
  (:require 
    [reagent.core :as r]
    [clojure.string :as str]
    [latin-texts.utils :refer [remove-macrons]]))

;; (defn remove-macrons [s]
;;   (-> s
;;       (clojure.string/replace #"ā" "a")
;;       (clojure.string/replace #"Ā" "A")
;;       (clojure.string/replace #"ē" "e")
;;       (clojure.string/replace #"Ē" "E")
;;       (clojure.string/replace #"ī" "i")
;;       (clojure.string/replace #"Ī" "I")
;;       (clojure.string/replace #"ō" "o")
;;       (clojure.string/replace #"Ō" "O")
;;       (clojure.string/replace #"ū" "u")
;;       (clojure.string/replace #"Ū" "U")
;;       (clojure.string/replace #"ȳ" "y")))

;; AI disclosure: this particular component was mostly generated by Grok
;; It's a 'good-enough' usability improvement for the prototype
(defn autocomplete
  "Props:
   - value       (r/atom with current input text)
   - on-change   (fn [new-value])
   - suggestions (vector of strings)
   - on-select   (optional) (fn [selected-string])
   - placeholder (optional)
   - class       (optional)"
  [{:keys [value on-change suggestions on-select placeholder class]}]
  (r/with-let [open?          (r/atom false)
               selected-idx   (r/atom -1) ;; -1 = no selection
               input-ref      (r/atom nil)]

    (let [current      @value
          normalized   (-> current str/trim str/lower-case remove-macrons)
          filtered     (when (and (seq current) @open?)
                         (->> suggestions
                              (filter #(str/starts-with? (str/lower-case (remove-macrons %)) normalized))
                              (sort)
                              (vec))) ;; vec for fast nth access

          count        (count filtered)
          show-dropdown? (and @open? (pos? count))

          move-selection!
          (fn [delta]
            (when show-dropdown?
              (swap! selected-idx
                     (fn [idx]
                       (let [next-idx (+ idx delta)]
                         (cond
                           (neg? next-idx)     (dec count) ;; wrap to bottom
                           (>= next-idx count) 0 ;; wrap to top
                           :else               next-idx))))))

          confirm-selection!
          (fn []
            (if (and show-dropdown? (not= -1 @selected-idx))
              (let [chosen (nth filtered @selected-idx)]
                (on-change chosen)
                (when on-select (on-select chosen))
                (reset! open? false)
                (reset! selected-idx -1))
              ;; If no suggestion highlighted → just accept what's typed
              (do
                (when on-select (on-select current))
                (reset! open? false)
                (reset! selected-idx -1))))]

      [:div.autocomplete.relative {:class class}
       [:input.w-full.px-3.py-2.border.rounded
        {:type        "text"
         :placeholder (or placeholder "Start typing...")
         :value       current
         :ref         (fn [el] (reset! input-ref el))
         :on-focus   #(reset! open? true)
         :on-blur    (fn [] (js/setTimeout #(reset! open? false) 180))
         :on-change   #(let [v (.. % -target -value)]
                         (reset! open? true)
                         (reset! selected-idx -1) ;; reset highlight on typing
                         (on-change v))
         :on-key-down
         (fn [e]
           (case (.-key e)
             "ArrowDown"   (do (.preventDefault e) (move-selection!  1))
             "ArrowUp"     (do (.preventDefault e) (move-selection! -1))
             "Enter"       (do (.preventDefault e) (confirm-selection!))
             "Escape"      (do (.preventDefault e)
                               (reset! open? false)
                               (reset! selected-idx -1))
             nil))}]
       
       (when show-dropdown?
         [:div.absolute.z-10.w-full.mt-1.bg-white.border.rounded.shadow-lg.max-h-64.overflow-auto
          (map-indexed
           (fn [idx suggestion]
             ^{:key suggestion}
             [:div.px-3.py-2.cursor-pointer
              (merge
               (when (= idx @selected-idx) {:style {:background-color "orange"}})
               {:on-click  #(do
                              (on-change suggestion)
                              (when on-select (on-select suggestion))
                              (reset! open? false)
                              (reset! selected-idx -1))})
              suggestion])
           filtered)])])))
